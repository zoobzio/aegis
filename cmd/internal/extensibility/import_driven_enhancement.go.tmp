package extensibility

import (
	"fmt"
	"strings"
	
	"github.com/spf13/cobra"
	
	"zbz/catalog"
	"zbz/pipz"
	"zbz/sctx"
)

// runImportDrivenTests demonstrates how importing packages adds capabilities
func runImportDrivenTests(cmd *cobra.Command, args []string) {
	runTest("Base Security Capabilities", testBaseSecurityCapabilities)
	runTest("Enhanced After Import", testEnhancedAfterImport)
	runTest("Multiple Enhancement Layers", testMultipleEnhancementLayers)
	runTest("Capability Competition", testCapabilityCompetition)
	runTest("Domain-Specific Imports", testDomainSpecificImports)
	runTest("Progressive Enhancement", testProgressiveEnhancement)
}

// Simulated package imports that add capabilities
func simulateGDPRImport() {
	// GDPR package adds right-to-forget capability
	contract := catalog.GetSecurityPipeline[UserProfile]()
	contract.Register(catalog.SecurityBehaviorKey("gdpr:forget"), 
		pipz.Processor[catalog.SecurityInput[UserProfile], catalog.SecurityOutput[UserProfile]](
			func(input catalog.SecurityInput[UserProfile]) catalog.SecurityOutput[UserProfile] {
				// Anonymize personal data
				data := input.Data
				data.Email = "forgotten@gdpr.eu"
				data.Name = "GDPR Forgotten User"
				data.Phone = "+00 000 0000"
				return catalog.SecurityOutput[UserProfile]{Data: data}
			},
		),
	)
}

func simulatePCIImport() {
	// PCI package adds credit card tokenization
	contract := catalog.GetSecurityPipeline[PaymentInfo]()
	contract.Register(catalog.SecurityBehaviorKey("pci:tokenize"),
		pipz.Processor[catalog.SecurityInput[PaymentInfo], catalog.SecurityOutput[PaymentInfo]](
			func(input catalog.SecurityInput[PaymentInfo]) catalog.SecurityOutput[PaymentInfo] {
				data := input.Data
				if len(data.CardNumber) > 4 {
					data.CardNumber = "TOK:" + generateToken() + ":" + data.CardNumber[len(data.CardNumber)-4:]
				}
				return catalog.SecurityOutput[PaymentInfo]{Data: data}
			},
		),
	)
}

func simulateHIPAAImport() {
	// HIPAA package adds medical data encryption
	contract := catalog.GetSecurityPipeline[MedicalRecord2]()
	contract.Register(catalog.SecurityBehaviorKey("hipaa:encrypt"),
		pipz.Processor[catalog.SecurityInput[MedicalRecord2], catalog.SecurityOutput[MedicalRecord2]](
			func(input catalog.SecurityInput[MedicalRecord2]) catalog.SecurityOutput[MedicalRecord2] {
				data := input.Data
				data.Diagnosis = "HIPAA:ENC:" + base64Encode(data.Diagnosis)
				data.Treatment = "HIPAA:ENC:" + base64Encode(data.Treatment)
				return catalog.SecurityOutput[MedicalRecord2]{Data: data}
			},
		),
	)
}

// Test data structures
type UserProfile struct {
	ID    string
	Email string
	Name  string
	Phone string
}

type PaymentInfo struct {
	UserID     string
	CardNumber string
	CVV        string
	ExpDate    string
}

type MedicalRecord2 struct {
	PatientID string
	Diagnosis string
	Treatment string
	Doctor    string
}

func testBaseSecurityCapabilities() error {
	// Before any imports, we have basic capabilities
	securityContract := catalog.GetSecurityPipeline[UserProfile]()
	
	// Register basic redaction
	securityContract.Register(catalog.RedactionBehavior,
		pipz.Processor[catalog.SecurityInput[UserProfile], catalog.SecurityOutput[UserProfile]](
			func(input catalog.SecurityInput[UserProfile]) catalog.SecurityOutput[UserProfile] {
				data := input.Data
				data.Email = "[REDACTED]"
				return catalog.SecurityOutput[UserProfile]{Data: data}
			},
		),
	)
	
	// Test basic capability
	user := UserProfile{
		ID:    "user-123",
		Email: "user@example.com",
		Name:  "John Doe",
		Phone: "+1-555-1234",
	}
	
	ctx := sctx.NewUserContext("test", []string{"read"})
	input := catalog.SecurityInput[UserProfile]{Data: user, Context: ctx}
	
	result, exists := securityContract.Process(catalog.RedactionBehavior, input)
	if !exists {
		return fmt.Errorf("basic redaction should exist")
	}
	
	if result.Data.Email != "[REDACTED]" {
		return fmt.Errorf("basic redaction failed")
	}
	
	// GDPR capability shouldn't exist yet
	_, gdprExists := securityContract.Process(catalog.SecurityBehaviorKey("gdpr:forget"), input)
	if gdprExists {
		return fmt.Errorf("GDPR capability shouldn't exist before import")
	}
	
	return nil
}

func testEnhancedAfterImport() error {
	// Simulate importing GDPR compliance package
	simulateGDPRImport()
	
	// Now we have GDPR capabilities
	securityContract := catalog.GetSecurityPipeline[UserProfile]()
	
	user := UserProfile{
		ID:    "user-456",
		Email: "jane@example.com",
		Name:  "Jane Smith",
		Phone: "+44-20-1234-5678",
	}
	
	ctx := sctx.NewUserContext("gdpr-request", []string{"gdpr:forget"})
	input := catalog.SecurityInput[UserProfile]{Data: user, Context: ctx}
	
	// GDPR forget capability now exists
	result, exists := securityContract.Process(catalog.SecurityBehaviorKey("gdpr:forget"), input)
	if !exists {
		return fmt.Errorf("GDPR capability should exist after import")
	}
	
	if result.Data.Email != "forgotten@gdpr.eu" {
		return fmt.Errorf("GDPR anonymization failed: %s", result.Data.Email)
	}
	
	if result.Data.Name != "GDPR Forgotten User" {
		return fmt.Errorf("GDPR name anonymization failed")
	}
	
	return nil
}

func testMultipleEnhancementLayers() error {
	// Import multiple compliance packages
	simulatePCIImport()
	simulateHIPAAImport()
	
	// Test PCI enhancement
	paymentContract := catalog.GetSecurityPipeline[PaymentInfo]()
	payment := PaymentInfo{
		UserID:     "user-789",
		CardNumber: "4111-1111-1111-1111",
		CVV:        "123",
		ExpDate:    "12/25",
	}
	
	ctx := sctx.NewPackageContext("payment-processor", []string{"pci:compliant"})
	paymentInput := catalog.SecurityInput[PaymentInfo]{Data: payment, Context: ctx}
	
	pciResult, _ := paymentContract.Process(catalog.SecurityBehaviorKey("pci:tokenize"), paymentInput)
	if !strings.HasPrefix(pciResult.Data.CardNumber, "TOK:") {
		return fmt.Errorf("PCI tokenization failed")
	}
	if !strings.HasSuffix(pciResult.Data.CardNumber, ":1111") {
		return fmt.Errorf("PCI should preserve last 4 digits")
	}
	
	// Test HIPAA enhancement
	medicalContract := catalog.GetSecurityPipeline[MedicalRecord2]()
	medical := MedicalRecord2{
		PatientID: "patient-001",
		Diagnosis: "Type 2 Diabetes",
		Treatment: "Insulin therapy",
		Doctor:    "Dr. Smith",
	}
	
	medicalInput := catalog.SecurityInput[MedicalRecord2]{Data: medical, Context: ctx}
	hipaaResult, _ := medicalContract.Process(catalog.SecurityBehaviorKey("hipaa:encrypt"), medicalInput)
	
	if !strings.HasPrefix(hipaaResult.Data.Diagnosis, "HIPAA:ENC:") {
		return fmt.Errorf("HIPAA encryption failed")
	}
	
	return nil
}

func testCapabilityCompetition() error {
	// Multiple packages can provide competing implementations
	
	// Basic encryption provider
	basicEncryption := func() {
		contract := catalog.GetSecurityPipeline[UserProfile]()
		contract.Register(catalog.EncryptionBehavior,
			pipz.Processor[catalog.SecurityInput[UserProfile], catalog.SecurityOutput[UserProfile]](
				func(input catalog.SecurityInput[UserProfile]) catalog.SecurityOutput[UserProfile] {
					data := input.Data
					data.Email = "BASIC:ENC:" + reverseString(data.Email)
					return catalog.SecurityOutput[UserProfile]{Data: data}
				},
			),
		)
	}
	
	// Advanced encryption provider (imported later, replaces basic)
	advancedEncryption := func() {
		contract := catalog.GetSecurityPipeline[UserProfile]()
		contract.Register(catalog.EncryptionBehavior,
			pipz.Processor[catalog.SecurityInput[UserProfile], catalog.SecurityOutput[UserProfile]](
				func(input catalog.SecurityInput[UserProfile]) catalog.SecurityOutput[UserProfile] {
					data := input.Data
					data.Email = "AES256:ENC:" + base64Encode(data.Email)
					data.Phone = "AES256:ENC:" + base64Encode(data.Phone)
					return catalog.SecurityOutput[UserProfile]{Data: data}
				},
			),
		)
	}
	
	// Start with basic
	basicEncryption()
	
	user := UserProfile{
		ID:    "user-999",
		Email: "test@example.com",
		Phone: "+1-555-9999",
	}
	
	ctx := sctx.NewPackageContext("test", []string{"encrypt"})
	input := catalog.SecurityInput[UserProfile]{Data: user, Context: ctx}
	
	contract := catalog.GetSecurityPipeline[UserProfile]()
	
	// Test basic encryption
	basicResult, _ := contract.Process(catalog.EncryptionBehavior, input)
	if !strings.HasPrefix(basicResult.Data.Email, "BASIC:ENC:") {
		return fmt.Errorf("basic encryption failed")
	}
	
	// Import advanced encryption (replaces basic)
	advancedEncryption()
	
	// Test advanced encryption
	advResult, _ := contract.Process(catalog.EncryptionBehavior, input)
	if !strings.HasPrefix(advResult.Data.Email, "AES256:ENC:") {
		return fmt.Errorf("advanced encryption should have replaced basic")
	}
	if !strings.HasPrefix(advResult.Data.Phone, "AES256:ENC:") {
		return fmt.Errorf("advanced encryption should encrypt phone too")
	}
	
	return nil
}

func testDomainSpecificImports() error {
	// Different domains get different security enhancements
	
	// Healthcare domain imports
	healthcareImports := func() {
		// Add patient privacy controls
		contract := catalog.GetSecurityContract[MedicalRecord]()
		contract.Register(catalog.SecurityBehaviorKey("healthcare:privacy"),
			pipz.Processor[catalog.SecurityInput[MedicalRecord], catalog.SecurityOutput[MedicalRecord]](
				func(input catalog.SecurityInput[MedicalRecord]) catalog.SecurityOutput[MedicalRecord] {
					data := input.Data
					// Only authorized doctors can see full records
					if !input.Context.HasPermission("doctor:" + data.Doctor) {
						data.Diagnosis = "[REQUIRES AUTHORIZATION]"
						data.Treatment = "[REQUIRES AUTHORIZATION]"
					}
					return catalog.SecurityOutput[MedicalRecord]{Data: data}
				},
			),
		)
	}
	
	// Financial domain imports
	financialImports := func() {
		// Add transaction limits
		contract := catalog.GetSecurityContract[PaymentInfo]()
		contract.Register(catalog.SecurityBehaviorKey("financial:limits"),
			pipz.Processor[catalog.SecurityInput[PaymentInfo], catalog.SecurityOutput[PaymentInfo]](
				func(input catalog.SecurityInput[PaymentInfo]) catalog.SecurityOutput[PaymentInfo] {
					// Check transaction limits based on user role
					if !input.Context.HasPermission("financial:unlimited") {
						// Limited users get masked CVV
						data := input.Data
						data.CVV = "***"
						return catalog.SecurityOutput[PaymentInfo]{Data: data}
					}
					return catalog.SecurityOutput[PaymentInfo]{Data: input.Data}
				},
			),
		)
	}
	
	// Import domain-specific enhancements
	healthcareImports()
	financialImports()
	
	// Test healthcare privacy
	medical := MedicalRecord{
		PatientID: "patient-123",
		Diagnosis: "Confidential",
		Treatment: "Restricted",
		Doctor:    "Dr. Jones",
	}
	
	// Unauthorized access
	unauthorizedCtx := sctx.NewUserContext("nurse", []string{"medical:read"})
	medInput := catalog.SecurityInput[MedicalRecord]{Data: medical, Context: unauthorizedCtx}
	
	medContract := catalog.GetSecurityContract[MedicalRecord]()
	privacyResult, _ := medContract.Process(catalog.SecurityBehaviorKey("healthcare:privacy"), medInput)
	
	if privacyResult.Data.Diagnosis != "[REQUIRES AUTHORIZATION]" {
		return fmt.Errorf("healthcare privacy failed for unauthorized user")
	}
	
	// Authorized access
	authorizedCtx := sctx.NewUserContext("Dr. Jones", []string{"medical:read", "doctor:Dr. Jones"})
	authInput := catalog.SecurityInput[MedicalRecord]{Data: medical, Context: authorizedCtx}
	
	authResult, _ := medContract.Process(catalog.SecurityBehaviorKey("healthcare:privacy"), authInput)
	if authResult.Data.Diagnosis != "Confidential" {
		return fmt.Errorf("authorized doctor should see full record")
	}
	
	return nil
}

func testProgressiveEnhancement() error {
	// Demonstrate how capabilities build on each other
	
	stepCount := 0
	
	// Step 1: Basic validation
	step1Import := func() {
		stepCount++
		contract := catalog.GetValidationPipeline[UserProfile]()
		contract.Register(catalog.RequiredValidation,
			pipz.Processor[catalog.ValidationInput[UserProfile], catalog.ValidationOutput[UserProfile]](
				func(input catalog.ValidationInput[UserProfile]) catalog.ValidationOutput[UserProfile] {
					if input.Data.Email == "" {
						return catalog.ValidationOutput[UserProfile]{
							Data:  input.Data,
							Error: fmt.Errorf("email required"),
						}
					}
					return catalog.ValidationOutput[UserProfile]{Data: input.Data}
				},
			),
		)
	}
	
	// Step 2: Format validation
	step2Import := func() {
		stepCount++
		contract := catalog.GetValidationPipeline[UserProfile]()
		contract.Register(catalog.FormatValidation,
			pipz.Processor[catalog.ValidationInput[UserProfile], catalog.ValidationOutput[UserProfile]](
				func(input catalog.ValidationInput[UserProfile]) catalog.ValidationOutput[UserProfile] {
					if !strings.Contains(input.Data.Email, "@") {
						return catalog.ValidationOutput[UserProfile]{
							Data:  input.Data,
							Error: fmt.Errorf("invalid email format"),
						}
					}
					return catalog.ValidationOutput[UserProfile]{Data: input.Data}
				},
			),
		)
	}
	
	// Step 3: Domain validation
	step3Import := func() {
		stepCount++
		contract := catalog.GetValidationPipeline[UserProfile]()
		contract.Register(catalog.ValidationBehaviorKey("domain"),
			pipz.Processor[catalog.ValidationInput[UserProfile], catalog.ValidationOutput[UserProfile]](
				func(input catalog.ValidationInput[UserProfile]) catalog.ValidationOutput[UserProfile] {
					if strings.HasSuffix(input.Data.Email, "@spam.com") {
						return catalog.ValidationOutput[UserProfile]{
							Data:  input.Data,
							Error: fmt.Errorf("blocked domain"),
						}
					}
					return catalog.ValidationOutput[UserProfile]{Data: input.Data}
				},
			),
		)
	}
	
	// Progressive imports
	step1Import()
	if stepCount != 1 {
		return fmt.Errorf("step 1 not imported")
	}
	
	step2Import()
	if stepCount != 2 {
		return fmt.Errorf("step 2 not imported")
	}
	
	step3Import()
	if stepCount != 3 {
		return fmt.Errorf("all steps should be imported")
	}
	
	// Test progressive validation
	contract := catalog.GetValidationPipeline[UserProfile]()
	
	// Test all validation layers
	testCases := []struct {
		email    string
		valid    bool
		errorMsg string
	}{
		{"", false, "email required"},
		{"notanemail", false, "invalid email format"},
		{"user@spam.com", false, "blocked domain"},
		{"valid@example.com", true, ""},
	}
	
	for _, tc := range testCases {
		user := UserProfile{Email: tc.email}
		input := catalog.ValidationInput[UserProfile]{Data: user}
		
		// Check each validation layer
		requiredResult, _ := contract.Process(catalog.RequiredValidation, input)
		if tc.email == "" && requiredResult.Error == nil {
			return fmt.Errorf("required validation should fail for empty email")
		}
		
		if tc.email != "" {
			formatResult, _ := contract.Process(catalog.FormatValidation, input)
			if !strings.Contains(tc.email, "@") && formatResult.Error == nil {
				return fmt.Errorf("format validation should fail for %s", tc.email)
			}
		}
	}
	
	return nil
}

// Helper functions
func generateToken() string {
	return "TOK" + fmt.Sprintf("%d", time.Now().UnixNano())
}

func base64Encode(s string) string {
	// Simple simulation
	return "base64:" + s
}

func reverseString(s string) string {
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return string(runes)
}