package extensibility

import (
	"fmt"
	"time"
	
	"github.com/spf13/cobra"
	
	"zbz/catalog"
	"zbz/pipz"
	"zbz/sctx"
)

// runCompileTimeGuaranteeTests demonstrates compile-time security
func runCompileTimeGuaranteeTests(cmd *cobra.Command, args []string) {
	runTest("Type Safety Enforcement", testTypeSafetyEnforcement)
	runTest("Wrong Type Detection", testWrongTypeDetection)
	runTest("Context Type Safety", testContextTypeSafety)
	runTest("Pipeline Type Checking", testPipelineTypeChecking)
	runTest("Behavior Type Isolation", testBehaviorTypeIsolation)
	runTest("Compile Time Validation", testCompileTimeValidation)
}

// Strongly typed domain models
type CompileTimeAdminUser struct {
	ID          string
	Permissions []string
	SecretKey   string
}

type SecureRegularUser struct {
	ID    string
	Email string
	Name  string
}

type PublicData struct {
	Title       string
	Description string
}

type PrivateData struct {
	SecretValue string
	AccessCode  string
}

// Type-specific security keys
type AdminSecurityKey string
type UserSecurityKey string
type PublicSecurityKey string

const (
	AdminEncrypt AdminSecurityKey = "encrypt"
	UserEncrypt  UserSecurityKey  = "encrypt"
	PublicView   PublicSecurityKey = "view"
)

func testTypeSafetyEnforcement() error {
	// Create type-specific contracts
	adminContract := pipz.GetContract[AdminSecurityKey, CompileTimeAdminUser, CompileTimeAdminUser]()
	userContract := pipz.GetContract[UserSecurityKey, SecureRegularUser, SecureRegularUser]()
	
	// Register processors
	adminContract.Register(AdminEncrypt, func(admin CompileTimeAdminUser) CompileTimeAdminUser {
		admin.SecretKey = "ADMIN:ENCRYPTED:" + admin.SecretKey
		return admin
	})
	
	userContract.Register(UserEncrypt, func(user SecureRegularUser) SecureRegularUser {
		user.Email = "USER:ENCRYPTED:" + user.Email
		return user
	})
	
	// Create test data
	admin := CompileTimeAdminUser{
		ID:          "admin-1",
		Permissions: []string{"all"},
		SecretKey:   "super-secret",
	}
	
	user := SecureRegularUser{
		ID:    "user-1",
		Email: "user@example.com",
		Name:  "Regular User",
	}
	
	// Process through correct contracts
	encryptedAdmin, _ := adminContract.Process(AdminEncrypt, admin)
	if encryptedAdmin.SecretKey != "ADMIN:ENCRYPTED:super-secret" {
		return fmt.Errorf("admin encryption failed")
	}
	
	encryptedUser, _ := userContract.Process(UserEncrypt, user)
	if encryptedUser.Email != "USER:ENCRYPTED:user@example.com" {
		return fmt.Errorf("user encryption failed")
	}
	
	// THE FOLLOWING WOULD NOT COMPILE:
	// adminContract.Process(AdminEncrypt, user)  // Wrong type!
	// userContract.Process(UserEncrypt, admin)   // Wrong type!
	// adminContract.Process(UserEncrypt, admin)  // Wrong key type!
	
	return nil
}

func testWrongTypeDetection() error {
	// Demonstrate that type mismatches are caught at compile time
	
	// Create a processor for private data
	privateContract := pipz.GetContract[AdminSecurityKey, PrivateData, PrivateData]()
	privateContract.Register(AdminSecurityKey("secure"), func(data PrivateData) PrivateData {
		data.SecretValue = "[SECURED]"
		data.AccessCode = "[SECURED]"
		return data
	})
	
	// Create a processor for public data
	publicContract := pipz.GetContract[PublicSecurityKey, PublicData, PublicData]()
	publicContract.Register(PublicView, func(data PublicData) PublicData {
		// Public data doesn't need securing
		return data
	})
	
	// Test data
	privateData := PrivateData{
		SecretValue: "confidential",
		AccessCode:  "12345",
	}
	
	publicData := PublicData{
		Title:       "Public Info",
		Description: "This is public",
	}
	
	// Process through correct contracts
	securedPrivate, _ := privateContract.Process(AdminSecurityKey("secure"), privateData)
	if securedPrivate.SecretValue != "[SECURED]" {
		return fmt.Errorf("private data not secured")
	}
	
	viewedPublic, _ := publicContract.Process(PublicView, publicData)
	if viewedPublic.Title != "Public Info" {
		return fmt.Errorf("public data not preserved")
	}
	
	// COMPILE-TIME SAFETY:
	// The following would be compile errors, not runtime errors:
	// privateContract.Process(PublicView, privateData)        // Wrong key type
	// publicContract.Process(AdminSecurityKey("secure"), publicData) // Wrong key type
	// privateContract.Process(AdminSecurityKey("secure"), publicData) // Wrong data type
	
	return nil
}

func testContextTypeSafety() error {
	// Security contexts are also type-safe
	
	// Admin-only operations
	type AdminOperation struct {
		Action string
		Target string
	}
	
	// User operations
	type UserOperation struct {
		Action string
		Scope  string
	}
	
	// Create typed contracts that require specific contexts
	adminOps := pipz.GetContract[AdminSecurityKey, AdminOperation, bool]()
	userOps := pipz.GetContract[UserSecurityKey, UserOperation, bool]()
	
	// Admin operations require admin context
	adminOps.Register(AdminSecurityKey("execute"), func(op AdminOperation) bool {
		// In real code, would check context permissions
		return op.Action == "delete" || op.Action == "modify"
	})
	
	// User operations have limited scope
	userOps.Register(UserSecurityKey("execute"), func(op UserOperation) bool {
		return op.Action == "read" && op.Scope == "own"
	})
	
	// Test operations
	adminOp := AdminOperation{Action: "delete", Target: "user-123"}
	userOp := UserOperation{Action: "read", Scope: "own"}
	
	// Execute with correct types
	adminAllowed, _ := adminOps.Process(AdminSecurityKey("execute"), adminOp)
	if !adminAllowed {
		return fmt.Errorf("admin operation should be allowed")
	}
	
	userAllowed, _ := userOps.Process(UserSecurityKey("execute"), userOp)
	if !userAllowed {
		return fmt.Errorf("user read operation should be allowed")
	}
	
	// COMPILE-TIME PROTECTION:
	// Cannot accidentally give user operations admin privileges:
	// adminOps.Process(AdminSecurityKey("execute"), userOp)  // Compile error!
	
	return nil
}

func testPipelineTypeChecking() error {
	// Demonstrate type-safe pipeline composition
	
	// Stage 1: Validation
	validationContract := pipz.GetContract[UserSecurityKey, SecureRegularUser, ValidationResult]()
	
	// Stage 2: Transformation (only accepts validated users)
	type ValidatedUser struct {
		User      SecureRegularUser
		Validated bool
	}
	transformContract := pipz.GetContract[UserSecurityKey, ValidatedUser, TransformedUser]()
	
	// Stage 3: Storage (only accepts transformed users)
	type TransformedUser struct {
		ID        string
		Formatted string
	}
	storageContract := pipz.GetContract[UserSecurityKey, TransformedUser, StorageResult]()
	
	type ValidationResult struct {
		Valid bool
		User  RegularUser
	}
	
	type StorageResult struct {
		Stored bool
		ID     string
	}
	
	// Register pipeline stages
	validationContract.Register(UserSecurityKey("validate"), func(user SecureRegularUser) ValidationResult {
		valid := user.Email != "" && user.Name != ""
		return ValidationResult{Valid: valid, User: user}
	})
	
	transformContract.Register(UserSecurityKey("transform"), func(validated ValidatedUser) TransformedUser {
		return TransformedUser{
			ID:        validated.User.ID,
			Formatted: fmt.Sprintf("%s <%s>", validated.User.Name, validated.User.Email),
		}
	})
	
	storageContract.Register(UserSecurityKey("store"), func(transformed TransformedUser) StorageResult {
		return StorageResult{
			Stored: true,
			ID:     transformed.ID,
		}
	})
	
	// Execute pipeline with type safety at each stage
	user := SecureRegularUser{ID: "123", Email: "test@example.com", Name: "Test User"}
	
	// Stage 1
	validationResult, _ := validationContract.Process(UserSecurityKey("validate"), user)
	if !validationResult.Valid {
		return fmt.Errorf("validation failed")
	}
	
	// Stage 2 - requires validated user
	validatedUser := ValidatedUser{User: validationResult.User, Validated: true}
	transformed, _ := transformContract.Process(UserSecurityKey("transform"), validatedUser)
	
	// Stage 3 - requires transformed user
	stored, _ := storageContract.Process(UserSecurityKey("store"), transformed)
	if !stored.Stored {
		return fmt.Errorf("storage failed")
	}
	
	// COMPILE-TIME SAFETY:
	// Cannot skip stages or use wrong types:
	// storageContract.Process(UserSecurityKey("store"), user)  // Wrong type!
	// transformContract.Process(UserSecurityKey("transform"), user)  // Wrong type!
	
	return nil
}

func testBehaviorTypeIsolation() error {
	// Show how behaviors are isolated by type
	
	// Financial data behaviors
	type FinancialData struct {
		Amount   float64
		Currency string
	}
	
	// Medical data behaviors
	type MedicalData struct {
		Condition string
		Severity  string
	}
	
	// Get behavior contracts
	financeSecurityContract := catalog.GetSecurityPipeline[FinancialData]()
	medicalSecurityContract := catalog.GetSecurityPipeline[MedicalData]()
	
	// Register same behavior key with different implementations
	financeSecurityContract.Register(catalog.EncryptionBehavior,
		pipz.Processor[catalog.SecurityInput[FinancialData], catalog.SecurityOutput[FinancialData]](
			func(input catalog.SecurityInput[FinancialData]) catalog.SecurityOutput[FinancialData] {
				data := input.Data
				data.Currency = "FIN:ENC:" + data.Currency
				return catalog.SecurityOutput[FinancialData]{Data: data}
			},
		),
	)
	
	medicalSecurityContract.Register(catalog.EncryptionBehavior,
		pipz.Processor[catalog.SecurityInput[MedicalData], catalog.SecurityOutput[MedicalData]](
			func(input catalog.SecurityInput[MedicalData]) catalog.SecurityOutput[MedicalData] {
				data := input.Data
				data.Condition = "MED:ENC:" + data.Condition
				return catalog.SecurityOutput[MedicalData]{Data: data}
			},
		),
	)
	
	// Test isolation
	financial := FinancialData{Amount: 1000.0, Currency: "USD"}
	medical := MedicalData{Condition: "Diabetes", Severity: "Moderate"}
	
	ctx := sctx.NewPackageContext("test", []string{"encrypt"})
	
	// Process through correct contracts
	finInput := catalog.SecurityInput[FinancialData]{Data: financial, Context: ctx}
	finResult, _ := financeSecurityContract.Process(catalog.EncryptionBehavior, finInput)
	
	medInput := catalog.SecurityInput[MedicalData]{Data: medical, Context: ctx}
	medResult, _ := medicalSecurityContract.Process(catalog.EncryptionBehavior, medInput)
	
	// Verify correct encryption applied
	if finResult.Data.Currency != "FIN:ENC:USD" {
		return fmt.Errorf("financial encryption incorrect")
	}
	
	if medResult.Data.Condition != "MED:ENC:Diabetes" {
		return fmt.Errorf("medical encryption incorrect")
	}
	
	// COMPILE-TIME ISOLATION:
	// Cannot accidentally use wrong contract:
	// financeSecurityContract.Process(catalog.EncryptionBehavior, medInput)  // Type error!
	// medicalSecurityContract.Process(catalog.EncryptionBehavior, finInput)  // Type error!
	
	return nil
}

func testCompileTimeValidation() error {
	// Demonstrate validation that happens at compile time
	
	// Required fields enforced by type system
	type RequiredUserData struct {
		ID    string // Can't be nil
		Email string // Can't be nil
		Age   int    // Can't be nil (zero value is valid)
	}
	
	// Optional fields use pointers
	type OptionalUserData struct {
		ID       string
		Nickname *string // Can be nil
		Bio      *string // Can be nil
	}
	
	// Contracts enforce types
	requiredContract := pipz.GetContract[UserSecurityKey, RequiredUserData, bool]()
	optionalContract := pipz.GetContract[UserSecurityKey, OptionalUserData, bool]()
	
	requiredContract.Register(UserSecurityKey("process"), func(data RequiredUserData) bool {
		// All fields guaranteed to exist (though may be empty string/zero)
		return data.ID != "" && data.Email != ""
	})
	
	optionalContract.Register(UserSecurityKey("process"), func(data OptionalUserData) bool {
		// Must check for nil on optional fields
		hasNickname := data.Nickname != nil && *data.Nickname != ""
		return data.ID != "" || hasNickname
	})
	
	// Create test data - compiler ensures all required fields
	required := RequiredUserData{
		ID:    "user-1",
		Email: "user@example.com",
		Age:   25,
	}
	// COMPILE ERROR if you try: required := RequiredUserData{ID: "user-1"}
	// Missing required fields won't compile!
	
	// Optional fields can be omitted
	optional1 := OptionalUserData{ID: "user-2"}
	nickname := "Johnny"
	optional2 := OptionalUserData{ID: "user-3", Nickname: &nickname}
	
	// Process data
	reqValid, _ := requiredContract.Process(UserSecurityKey("process"), required)
	if !reqValid {
		return fmt.Errorf("required data should be valid")
	}
	
	opt1Valid, _ := optionalContract.Process(UserSecurityKey("process"), optional1)
	if !opt1Valid {
		return fmt.Errorf("optional data with ID should be valid")
	}
	
	opt2Valid, _ := optionalContract.Process(UserSecurityKey("process"), optional2)
	if !opt2Valid {
		return fmt.Errorf("optional data with nickname should be valid")
	}
	
	return nil
}